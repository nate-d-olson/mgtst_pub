---
title: "Normalization Analysis"
author: "Nate Olson"
date: '`r Sys.Date()`'
output:
  pdf_document: default
  html_document: default
---

```{r message = FALSE}
library(metagenomeSeq)
library(tidyverse)
```

## Objective
* Assessment of count table values for different pipelines.
* Impact of normlization methods on count table values.

### Loading Pipeline Data
```{r}
mrexp_files <- list(
      dada2  = "../data/mrexp_dada2.RDS",
      mothur = "../data/mrexp_mothur.RDS",
      qiime  = "../data/mrexp_qiime_refclus_nochimera.RDS"
)
mrexp <- mrexp_files %>% map(readRDS) 
```

Extracting metadata
```{r}
meta_dat <- mrexp$mothur %>% pData()

##labeling PCR replicates
half1 <- paste(rep(c("A","B","C","D","E","F","G","H"), each = 6),1:6, sep = "_")
sam_dat <- meta_dat %>% 
      mutate(pcr_half = if_else(pos %in% half1, "1","2"),
             pcr_rep = paste0(pcr_16S_plate,":",pcr_half)) %>% 
      select(sampleID, dilution,sam_names, pcr_rep) %>% 
      rename(samID = sam_names)
```


## Subsetting data to focus on one biological replicate
Only looking at biological replicate E01JH0004

```{r}
E01JH004_sams <- meta_dat %>% 
      filter(sampleID == "E01JH0004") %>% .$sam_names
mrexp_004 <- mrexp %>% 
      map(~.[,which(colnames(.) %in% E01JH004_sams)]) %>% 
      map(~.[which(rowSums(MRcounts(.)) > 0), ])
```


## Raw, Normalized, and Transformed Count Data
Question - does the order of the normalization and log transformation matter? 

```{r}
calc_raw_counts <- function(mrexp){
      mrexp@assayData$counts %>% as_tibble() %>% 
            rownames_to_column(var = "otuID") %>% 
            gather("samID","count",-otuID) %>% 
            left_join(sam_dat) 
}

calc_css_counts <- function(mrexp, norm = TRUE,log = TRUE,sl = 1000, p = 0.75){
      ## col_id is the name of the col in the output 
      ## dataframe with the css normalized counts
      #mrexp %>% cumNormMat(p = p) %>% as_tibble() %>% 
      mrexp %>% cumNorm(p = p) %>% 
            MRcounts(norm, log, sl) %>% as_tibble() %>% 
            rownames_to_column(var = "otuID") %>% 
            gather("samID","count",-otuID) %>% 
            left_join(sam_dat) 
}

# TSS from http://mixomics.org/mixmc/normalisation/ 
calc_tss_counts <- function(mrexp){
      mrexp@assayData$counts %>% {apply(., 2, function(x){ x/sum(x) })} %>% 
            as_tibble() %>% rownames_to_column(var = "otuID") %>%
            gather("samID","count",-otuID) %>% 
            left_join(sam_dat) 
}

calc_tsslog_counts <- function(mrexp){
      mrexp@assayData$counts %>% 
            {apply(., 2, function(x){ x/sum(x) })} %>% {log2(. + 1)} %>%
            as_tibble() %>% rownames_to_column(var = "otuID") %>%
            gather("samID","count",-otuID) %>% 
            left_join(sam_dat) 
}
```

```{r message = FALSE}
raw_counts <- mrexp_004 %>% map_df(calc_raw_counts, .id = "pipe")
rawlog_counts <- mrexp_004 %>% map_df(calc_raw_counts, .id = "pipe") %>% 
      mutate(count = log2(count + 1))
```

```{r message = FALSE}
css_counts <- mrexp_004 %>% map_df(calc_css_counts, log = FALSE, .id = "pipe")
csslog_counts <- mrexp_004 %>% map_df(calc_css_counts, .id = "pipe")
```

```{r message = FALSE}
tss_counts <- mrexp_004 %>% map_df(calc_tss_counts, .id = "pipe")
tsslog_counts <- mrexp_004 %>% map_df(calc_tsslog_counts, .id = "pipe") 
```

Combine into a single data frame
```{r}
count_df <- list(raw = raw_counts, rawlog = rawlog_counts, 
                 css = css_counts, csslog = csslog_counts, 
                 tss = tss_counts, tsslog = tsslog_counts) %>% 
      bind_rows(.id = "norm_method")
```


## Count Value Variance 
Relationship between the mean count and variance for the four PCR replicates. 
Note the heteroscedasicity, increase in variance with mean counts. 

```{r}
count_var_df <- count_df %>% group_by(pipe, norm_method, dilution, otuID) %>% 
      summarise(mean_count  = mean(count),
                var_count   = var(count),
                lmean_count = log2(mean_count),
                lvar_count = log2(var_count),
                diff_lmean_lvar = log2((var_count)/(mean_count)))
```

Interesting distribution for dada2 mean variance relationship. 
Higher variance for lower count values expected. 

```{r fig.height = 10}
# log mean x, log variance - log mean y : expectation of 1
ggplot(count_var_df) +
      # geom_point(aes(x = mean_count, y = var_count), alpha = 0.5) +
      # geom_hex(aes(x = mean_count, y = var_count)) +
      geom_hex(aes(x = lmean_count, y = diff_lmean_lvar)) +
      facet_grid(norm_method~pipe) +
      theme_bw() + labs(x = "log2(Mean)", y = "log2(Variance/Mean)")
```


## Count Value Bias 
Relationship between the observed and expected count values. Expected count ($C_{exp}$)values calculated using the unmixed sample count values (unmixed pre - $C_{pre}$ and unmixed post - $C_{post}$) and proportion of unmixed pre in the titration $p$. Proportion is defined as $p = 2^{-t}$, and $t$ is the titration factor. 

$$
C_{exp} = [C_{pre}\times p] + [C_{post} \times (1-p)]
$$
The expected values are calculated based on pre and post unmixed samples by replicate (defined as half of PCR plate).


```{r}
pre_count <- count_df %>% filter(dilution == -1) %>% 
      rename(pre = count) %>% select(-dilution, -samID)
post_count <- count_df %>% filter(dilution == 0) %>% 
      rename(post = count) %>% select(-dilution, -samID)
pre_post_count <- left_join(pre_count, post_count)
rm(pre_count, post_count)

count_exp_obs <- count_df %>% 
      filter(!(dilution %in% c(0,-1))) %>%
      left_join(pre_post_count) %>% 
      mutate(p = 2^(-dilution), exp_count = post * (1-p) + pre * p)
```


## Metrics for evaluating count values

The overall pipeline and normalization method performance was evaluated using root mean squared error (RMSE) and the normalized RMSE (NRMSE). 
Normalizing RMSE allow for the comparison of metric value across pipeline and normalization methods. 
Overall the count table generated using the DADA2 sequence inference based method  with CSS normalization and log2 transformation had the lowest NRMSE. 
The NRMSE for the QIIME pipeline, open reference clustering, was comparable for CSS and TSS normalization method.  
Log2 transformation lowered that NRMSE for all three pipelines more than either TSS or CSS normalization. 


```{r}
count_rmse <- count_exp_obs %>% mutate(residual = (exp_count - count)^2) %>% 
      group_by(pipe, norm_method) %>% 
      summarise(mse = mean(residual), 
                rmse = sqrt(mse), 
                nrmse = rmse/mean(exp_count))
```

RMSE - pipeline and normalization method
```{r}
count_rmse %>% select(-mse, -nrmse) %>% 
      spread(norm_method, rmse) %>% knitr::kable()
```

NRMSE - pipeline and normalization mehod 
```{r}
count_rmse %>% select(-mse, -rmse) %>% 
      spread(norm_method, nrmse) %>% knitr::kable()
```


Black line indicates expected 1 to 1 relationship between the expected and observed values.
```{r fig.height = 6}
count_exp_obs %>% filter(norm_method %in% c("csslog","tsslog", "rawlog")) %>% 
      ggplot() + 
      geom_hex(aes(x = count, y = exp_count)) + 
      geom_abline(aes(intercept = 0, slope = 1)) + 
      facet_wrap(pipe~norm_method, ncol = 3, scales = "free") + 
      theme_bw() + labs(x = "Observed Counts", y = "Expected Counts")
```


## Metrics for evaluating count values excluding 0 
When excluding observed 0 count values the NRMSE are significantly lower for all pipelines. 

```{r}
count_rmse <- count_exp_obs %>% filter(count != 0) %>% 
      mutate(residual = (exp_count - count)^2) %>% 
      group_by(pipe, norm_method) %>% 
      summarise(mse = mean(residual), 
                rmse = sqrt(mse), 
                nrmse = rmse/mean(exp_count))
```

RMSE - pipeline and normalization method
```{r}
count_rmse %>% select(-mse, -nrmse) %>% 
      spread(norm_method, rmse) %>% knitr::kable()
```

NRMSE - pipeline and normalization mehod 
```{r}
count_rmse %>% select(-mse, -rmse) %>% 
      spread(norm_method, nrmse) %>% knitr::kable()
```

Black line indicates expected 1 to 1 relationship between the expected and observed values.
```{r fig.height = 6}
count_exp_obs %>% filter(norm_method %in% c("csslog","tsslog", "rawlog"), count != 0) %>% 
      ggplot() + 
      geom_hex(aes(x = count, y = exp_count)) + 
      geom_abline(aes(intercept = 0, slope = 1)) + 
      facet_wrap(pipe~norm_method, ncol = 3, scales = "free") + 
      theme_bw() + labs(x = "Observed Counts", y = "Expected Counts")
```
