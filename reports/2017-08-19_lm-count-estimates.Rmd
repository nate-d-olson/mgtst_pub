---
title: "Negative Binomial Linear Model Count Estimates"
author: "Nate Olson"
date: '`r Sys.Date()`'
always_allow_html: yes
output:
  pdf_document: default
  html_document: default
---

```{r setup, warning=FALSE, message=FALSE, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(MASS)
library(modelr)
library(ProjectTemplate)
cwd <- getwd()
setwd("../")
load.project()
setwd(cwd) 
pipeline_dir <- "../../mgtst_pipelines"
mrexp <- get_mrexp(pipeline_dir)
```

## Summary
Using a negative binomial generalized linear model to calculate feature proportion estimates across the four PCR replicates accounting for differences in sampling depth.

```{r}

## TODO - can replace with loading Raw Counts DF
get_count_df <- function(mrobj, agg_genus = FALSE, css = TRUE){
      if(agg_genus){
            mrobj <- aggregateByTaxonomy(mrobj, lvl = "Rank6", 
                                         norm = FALSE, log = FALSE, sl = 1)
      }
      
      if(css == TRUE){
            mrobj <- cumNorm(mrobj, p = 0.75)
            count_mat <- MRcounts(mrobj, norm = TRUE, log = FALSE, sl = 1000)
      }else{
            count_mat <- MRcounts(mrobj, norm = FALSE, log = FALSE, sl = 1)
      }
       count_mat %>%  
            as.data.frame() %>% 
            rownames_to_column(var = "feature_id") %>% 
            gather("id","count", -feature_id)
}

count_df <- mrexp %>% 
      map_df(get_count_df, css = FALSE, .id = "pipe") %>% 
      left_join(pData(mrexp$dada2)) %>% 
      filter(biosample_id != "NTC") %>% 
      dplyr::select(pipe, biosample_id, id, pcr_rep, feature_id, t_fctr, count) %>% 
      group_by(biosample_id, pipe, id) %>% 
      mutate(total_abu = sum(count))

## Excluding features with no observed counts for an individual 
nonzero_count_features <- count_df %>% 
      mutate(t_fctr = factor(t_fctr, levels = c(0:5,10,15,20))) %>% 
      group_by(pipe, biosample_id, feature_id) %>% 
      summarise(total_count = sum(count)) %>% 
      filter(total_count > 0) %>% 
      dplyr::select(-total_count)

## Excluding titrations with zero counts for all four PCR replicates
titration_counts <- count_df %>% 
      right_join(nonzero_count_features) %>% 
       mutate(t_fctr = factor(t_fctr, levels = c(0:5,10,15,20))) %>% 
      group_by(pipe, biosample_id, feature_id, t_fctr) %>% 
      summarise(total_count = sum(count)) 

zero_titrations <- titration_counts %>%
      filter(total_count == 0) %>% 
      dplyr::select(-total_count) 

nonzero_titrations <- titration_counts %>% 
      filter(total_count > 0) %>% 
      dplyr::select(-total_count)

### Filtering nonzero features and modifying data frame to fit model      
nested_count_df <- count_df %>% 
      mutate(t_fctr = factor(t_fctr, levels = c(0:5,10,15,20))) %>% 
      right_join(nonzero_count_features) %>% 
      right_join(nonzero_titrations) %>% 
      group_by(pipe, biosample_id, feature_id) %>%
      nest()
```

## Issue with unmix specific features
No unmix specific features were observed for dada2 E01JH0017 and E01JH0038. 
```{r}
zero_titrations %>% filter(feature_id == "SV1077", biosample_id == "E01JH0017")
```

Example where counts are only observed for one titration. 
```{r}
test_df <- count_df %>% filter(feature_id == "SV1077", biosample_id == "E01JH0017") %>% filter(t_fctr == 20)
```

```{r}
test_df
```

Unable to fit model when only one titration
```{r}
glm.nb(count ~ t_fctr + offset(log(total_abu)), data = test_df, link = "log")
```
Able to fit model when only excluding t_fctr from the model. 
Potential alternative solution is to fit the negative binomial model to each titration individual instead of by feature. 
```{r}
glm.nb(count ~ offset(log(total_abu)), data = test_df, link = "log")
```

```{r}
## Using safely to fit negative binomial to catch model fix errors
safe_glm.nb <- safely(glm.nb)

nb_fit <- nested_count_df %>%
      mutate(fit = map(data, 
                       ~safe_glm.nb(count ~ t_fctr + offset(log(total_abu)), 
                                    data = ., 
                                    link = "log"))) 

saveRDS(nb_fit, "~/Desktop/nb_fit.RDS")
#nb_fit <- readRDS("~/Desktop/nb_fit.RDS")

### Filtering failed models
fit_results <- nb_fit$fit %>% 
      transpose() %>% 
      as_data_frame()

nb_fit_results <- nb_fit %>% 
      dplyr::select(-fit) %>%
      bind_cols(fit_results) %>% 
      mutate(ok_model = map_lgl(error, is_null)) 

### Extracting proportion estimates
## Using add_predictions to get proportions estimates. 
## Removes need to account for differences in intercept when some or all of the titrations are excluded from the model fit due to no observed counts. 
nb_counts <- nb_fit_results %>% 
      filter(ok_model == T) %>% 
      mutate(data = map(data, mutate, `offset(log(total_abu)))` = offset(log(total_abu)))) %>% 
      mutate(data = map2(data, result, add_predictions)) %>%
      dplyr::select(-result, -error, -ok_model) %>%
      unnest() %>% 
      mutate(nb_prop = exp(pred)/total_abu) %>% 
      ## Proportion estimates for each PCR replicate - using mean as values are not unique
      group_by(pipe, biosample_id, feature_id, t_fctr) %>% 
      summarise(nb_prop = mean(nb_prop))


# ## set zero titrations to zero
## Might want to excluding zero titrations for features with bad model fits
zero_titrations <- zero_titrations %>% mutate(nb_prop = 0)
nb_counts <- nb_counts %>% full_join(zero_titrations)

saveRDS(nb_counts, "~/Desktop/nb_counts.RDS")
```

Sanity check for proportion estimates are between 0 and 1

```{r}
min(nb_counts$nb_prop) < 0
```
```{r}
max(nb_counts$nb_prop) > 1
```


Failed models have high proportion of zeros

Need approach to summarise failed model fits and zero counts
Compare with pa_summary pa totals
```{r}
bad_models <- nb_fit_results %>% 
      filter(ok_model == F) 
```



